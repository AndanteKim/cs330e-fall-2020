Operators.py
------------
Boolean operators are typically used on boolean values. Examples, and, or, not 
Bitwise operators are typically used  on integral values. Examples, ~, |, &, >>, <<

operators precedence: https://www.programiz.com/python-programming/precedence-associativity

Example (corrections from in-class discussion):
i = 8
j = not i & (i - 1)
assert j is True      # power of 2

i & (i - 1) will be conducted first since & has higher precedence than not, 
i.e., 1000 & 0111, and the result will be False

j = not False 

j = True

iteration.py: 
------------
Iterables:
- an iterable is an object that you can iterate through.
- iterables usually have the property "__getitem__" 
  that indicates an object is indexable.

>>> x=[2, 3, 4]
>>> hasattr(x, "__iter__")
True
>>> hasattr(x, "__getitem__")
True
>>> hasattr(x, "__next__")
False

Iterators vs generators:
- an iterator object is an object that has the "__iter__" and "__next__" attribute.
- you can get an iterator out of an iterable using iter function.
- generator functions allow you to declare a function that behaves like an iterator, 
  i.e. it can be used in a for loop.
- every generator is an iterator.

iter(): takes an iterable object and returns an iterator.
>>> x=[2, 3, 4]
>>> p = iter(x)
>>> next(p)
2
>>> next(p)
3
>>> next(p)
4
>>> next(p)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration
>>>
------------
https://nvie.com/posts/iterators-vs-generators/
https://data-flair.training/blogs/python-generator-vs-iterator/

Factorial.py and FactorialT.py
------------------------------
Factorial.py:
------------
factorial_recursion
•	Perform recursive calls first, then take the return value of 
the recursive call and calculate the result.  The result won't 
be calculated until you have returned from every recursive call.
•	You need to keep stack frames until the recursion is over 
-- O(n) space. 

factorial_tail_recursion
•	Note that a function inside a function is allowed in Python. 
•	Perform your calculations first and then execute the 
recursive call, passing the results of the current step to 
the next recursive step. 
•	We are reusing the current stack frame so we will never get stack overflow.
•	Some compliers transfer tail recursive functions into loop (but not in Python).
•	Procedure is recursive but the process is not.

FactorialT.py:
------------
with self.subTest(): if one of the test fails, this would be 
the end of test_0. with keeps the test going until it goes through all. 

timeit:
•	timeit function takes three arguments.
•	f.__name__ obtains the name of the current function and "(100)" is the argument to the function.
•	"from __main__ import " + f.__name__ imports the definition of the function
•	number = 1000, determine how many times we are going to run the function.
•	The result, t, is printed after multiply it with 1000 because timeit provides results in microseconds 
and we need it in milliseconds.
